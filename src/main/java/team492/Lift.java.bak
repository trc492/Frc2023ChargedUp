/*
 * Copyright (c) 2023 Titan Robotics Club (http://www.titanrobotics.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package team492;ikokoopkpokpo

import java.lang.reflect.Parameter;

import TrcCommonLib.trclib.TrcEvent;
import TrcCommonLib.trclib.TrcPidActuator;
import TrcCommonLib.trclib.TrcPidController;
import TrcCommonLib.trclib.TrcTimer;
import TrcFrcLib.frclib.FrcCANFalcon;
import TrcFrcLib.frclib.FrcDigitalInput;

public class Lift 
{
    private static class ActionParams
    {
        double target;
        double powerLimit;
        TrcEvent event;
        TrcNotifier.Receiver callback;
        double timeout;
        Double xTarget;
        Double yTarget;
    }   //class ActionParams

    private static final String moduleName = "Lift";
    private final Robot robot;
    private final TrcPidActuator xLiftActuator;
    private final TrcPidActuator yLiftActuator;
    private final TrcTimer delayTimer;
    private final FrcDigitalInput lowerLimitSwitch;
    private final FrcDigitalInput upperLimitSwitch;

    private double turretTarget = 0.0;
    private double turretPowerLimit = 1.0;
    private TrcEvent turretEvent = null;
    private TrcNotifier.Receiver turretCallback = null;
    private double turretTimeout = 0.0;ikjnjkjknk
    private Double turretElevatorTarget = null;
    private Double turretArmTarget = null;
    private boolean armLevelSafe = false;
    private boolean elevatorLevelSafe = false;
    private double prevTurretPower = 0.0;
    private final ActionParams actionParams = new ActionParams();

    public Lift(Robot robot)
    {
        this.robot = robot;

        final TrcPidActuator.Parameters liftParams = new TrcPidActuator.Parameters()
        .setPosRange(RobotParams.LIFT_MIN_POS, RobotParams.LIFT_MAX_POS)
        .setScaleOffset(RobotParams.LIFT_INCHES_PER_COUNT, RobotParams.LIFT_OFFSET)
        .resetPositionOnLowerLimit(false)
        .setPidParams(new TrcPidController.PidParameters(
            RobotParams.LIFT_KP, RobotParams.LIFT_KI, RobotParams.LIFT_KD,
            RobotParams.LIFT_TOLERANCE))

        .setPresetTolerance(RobotParams.LIFT_PRESET_TOLERANCE)
        .setPosPresets(RobotParams.LIFT_PRESET_LEVELS);



        

        FrcCANFalcon liftMotor = new FrcCANFalcon("XLiftMotor", RobotParams.CANID_LIFT_MOTOR);
        liftActuator = new TrcPidActuator(
            "XLift", liftMotor, lowerLimitSwitch, upperLimitSwitch, liftParams);



        

    }
    /**
     * This method returns the PID actuator object.
     *
     * @return PID Actuator object.
     */
    public TrcPidActuator getPidActuatorX()
    {
        return xLiftActuator;
    }   //getPidActuator

    public TrcPidActuator getPidActuatorY()
    {
        return yLiftActuator;
    }   //getPidActuator

    /**
     * This method returns the current turret position in degrees.
     *
     * @return turret position in degrees.
     */
    public double getPositionX()
    {
        return xLiftActuator.getPositionX();
    }   //getPosition

    public double getPositionY()
    {
        return yLiftActuator.getPositionY();
    }   //getPosition


    /**
     * This method checks if the zero position switch is active.
     *
     * @return true if the zero position switch is active, false otherwise.
     */
    public boolean isZeroPosSwitchActive()
    {
        return pidTurret.isLowerLimitSwitchActive();
    }   //isZeroPosSwitchActive

   
    /**
     * This method zero calibrates the turret by first zero calibrating the arm and elevator. Once the arm and
     * elevator are zero calibrated, we will know the exact arm and elevator positions. Also, the arm is zero
     * calibrated upward. This allows the turret to turn without hitting anything. Therefore, zero calibrating
     * the turret involves 3 steps:
     *  1. zero calibrate the elevator.
     *  2. zero calibrate the arm and wait for its calibration to be done (chain to the armZeroCalDone handler).
     *  3. In the armZeroCalDone handler, do a fire and forget zero calibrate on the turret.
     */
    
     public void zeroCalibrate()
    {
        robot.elevator.zeroCalibrate(RobotParams.ELEVATOR_CAL_POWER);
        robot.arm.zeroCalibrate(RobotParams.ARM_CAL_POWER, this::armZeroCalDoneCallback);
    }   //zeroCalibrate

    /**
     * This method is called after the arm zero calibration is done so that we know it's safe to zero calibrate the
     * turret.
     *
     * @param context not used.
     */
    private void armZeroCalDoneCallback(Object context)
    {
        double calPower = Math.abs(RobotParams.TURRET_CAL_POWER);

        pidTurret.zeroCalibrate(calDirectionSwitch.isActive()? calPower: -calPower);
    }   //armZeroCalDoneCallback

    /**
     * This method sets the turret to the specified preset position.
     *
     * @param preset specifies the index to the preset position array.
     */
    public void setPresetPosition(int preset)
    {
        if (pidLift.validatePresetIndex(preset))
        {
            setTarget(RobotParams.XLIFT_PRESET_LEVELS[preset], 1.0, null, null, 0.0, null, null);
            setTarget(RobotParams.YLIFT_PRESET_LEVELS[preset], 1.0, null, null, 0.0, null, null);
        }
    }   //setPresetPosition

    /**
     * This method moves the turret to the next position up the preset list.
     */
    public void presetPositionUp()
    {
        setPresetPosition(pidTurret.nextPresetIndexUp());
    }   //presetPositionUp

    /**
     * This method moves the turret to the next position down the preset list.
     */
    public void presetPositionDown()
    {
        setPresetPosition(pidTurret.nextPresetIndexDown());
    }   //presetPositionDown

    /**
     * This method is called after the delay timer has expired to perform the turret action.
     *
     * @param context not used.
     */
    private void performAction(Object context)
    {
        setTarget(actionParams.target, actionParams.powerLimit, actionParams.event, actionParams.callback,
                  actionParams.timeout, actionParams.elevatorTarget, actionParams.armTarget);
    }   //performAction

    /**
     * This method sets the turret target position. It first checks if it's safe for the turret to turn without
     * hitting anything. If it's not safe, it will first raise the arm above the "safe level" before setting the
     * target for the turret.
     *
     * @param delay specifies the delay in seconds before performing the action.
     * @param target specifies the target position of the turret in degrees.
     * @param powerLimit specifies the maximum power the turret will turn.
     * @param event specifies the event to signal when the turret is on target, can be null if not provided.
     * @param callback specifies the notify callback to call when the turret is on target, can be null if not provided.
     * @param timeout specifies timeout in seconds for the operation.
     * @param elevatorTarget specifies optionally the elevator target, can be null if no additional elevator movement.
     * @param armTarget specifies optionally the arm target, can be null if no additional arm movement.
     */
    public void setTarget(
        double delay, double target, double powerLimit, TrcEvent event, TrcNotifier.Receiver callback, double timeout,
        Double elevatorTarget, Double armTarget)
    {
        if (delay > 0.0)
        {
            actionParams.target = target;
            actionParams.powerLimit = powerLimit;
            actionParams.event = event;
            actionParams.callback = callback;
            actionParams.timeout = timeout;
            actionParams.elevatorTarget = elevatorTarget;
            actionParams.armTarget = armTarget;
            delayTimer.set(delay, this::performAction);
        }
        else
        {
            setTarget(target, powerLimit, event, callback, timeout, elevatorTarget, armTarget);
        }
    }   //setTarget

    /**
     * This method sets the turret target position. It first checks if it's safe for the turret to turn without
     * hitting anything. If it's not safe, it will first raise the arm above the "safe level" before setting the
     * target for the turret.
     *
     * @param target specifies the target position of the turret in degrees.
     * @param powerLimit specifies the maximum power the turret will turn.
     * @param event specifies the event to signal when the turret is on target, can be null if not provided.
     * @param callback specifies the notify callback to call when the turret is on target, can be null if not provided.
     * @param timeout specifies timeout in seconds for the operation.
     * @param elevatorTarget specifies optionally the elevator target, can be null if no additional elevator movement.
     * @param armTarget specifies optionally the arm target, can be null if no additional arm movement.
     */
    public void setTarget(
        double target, double powerLimit, TrcEvent event, TrcNotifier.Receiver callback, double timeout,
        Double elevatorTarget, Double armTarget)
    {
        double armPos = robot.arm.getPosition();
        double elevatorPos = robot.elevator.getPosition();

        armLevelSafe = armPos <= RobotParams.ARM_MIN_POS_FOR_TURRET;
        elevatorLevelSafe = elevatorPos >= RobotParams.ELEVATOR_MIN_POS_FOR_TURRET;
        if (!turnTurretToPos(target, powerLimit, event, callback, timeout, elevatorTarget, armTarget))
        {
            // Either the arm or the elevator are not at safe level, we need to raise them first before the turn.
            turretTarget = target;
            turretPowerLimit = powerLimit;
            turretEvent = event;
            turretCallback = callback;
            turretTimeout = timeout;
            turretElevatorTarget = elevatorTarget;
            turretArmTarget = armTarget;

            if (!armLevelSafe)
            {
                // Acquiring arm ownership will prevent teleop from interfering with our arm movement.
                if (robot.arm.acquireExclusiveAccess(moduleName))
                {
                    robot.arm.setTarget(
                        moduleName, RobotParams.ARM_POS_FOR_TURRET_TURN, false, 1.0, null,
                        this::armRaiseDoneCallbackWithTurretTurn, 0.0);
                }
            }

            if (!elevatorLevelSafe)
            {
                // Acquiring elevator ownership will prevent teleop from interfering with our elevator movement.
                if (robot.elevator.acquireExclusiveAccess(moduleName))
                {
                    robot.elevator.setTarget(
                        moduleName, RobotParams.ELEVATOR_POS_FOR_TURRET_TURN, true, 1.0, null,
                        this::elevatorRaiseDoneCallbackWithTurretTurn, 0.0);
                }
            }
        }
    }   //setTarget

    /**
     * This method sets the turret target position. It first checks if it's safe for the turret to turn without
     * hitting anything. If it's not safe, it will first raise the arm above the "safe level" before setting the
     * target for the turret.
     *
     * @param target specifies the target position of the turret in degrees.
     * @param powerLimit specifies the maximum power the turret will turn.
     */
    public void setTarget(double target, double powerLimit)
    {
        setTarget(target, powerLimit, null, null, 0.0, null, null);
    }   //setTarget

    /**
     * This method sets the turret target position. It first checks if it's safe for the turret to turn without
     * hitting anything. If it's not safe, it will first raise the arm above the "safe level" before setting the
     * target for the turret.
     *
     * @param target specifies the target position of the turret in degrees.
     */
    public void setTarget(double target)
    {
        setTarget(target, 1.0, null, null, 0.0, null, null);
    }   //setTarget

    /**
     * This method sets the turret in motion with the given power but it will first check if it's safe to turn the
     * turret. If not, it will instead raise the arm to above the safe level. Since setPower is generally called by
     * TeleOp code, it will not do the actual setPower after raising the arm because by the time the arm is raised
     * the gamepad control may have a different turret power value. Therefore, the TeleOp code will call again with
     * the new power value and this time it is safe to turn the turret.
     *
     * @param power specifies the power value to turn the turret.
     * @param usePid specifies true to use PID control, false otherwise.
     */
    public void setPower(double power, boolean usePid)
    {
        if (power != prevTurretPower)
        {
            if (power == 0.0)
            {
                prevTurretPower = power;
                pidTurret.setPidPower(power, false);
            }
            else
            {
                double armPos = robot.arm.getPosition();
                double elevatorPos = robot.elevator.getPosition();

                armLevelSafe = armPos <= RobotParams.ARM_MIN_POS_FOR_TURRET;
                elevatorLevelSafe = elevatorPos >= RobotParams.ELEVATOR_MIN_POS_FOR_TURRET;
                if (!turnTurretWithPower(power, usePid))
                {
                    if (!armLevelSafe)
                    {
                        if (robot.arm.acquireExclusiveAccess(moduleName))
                        {
                            robot.arm.setTarget(
                                moduleName, RobotParams.ARM_POS_FOR_TURRET_TURN, false, 1.0, null,
                                this::armRaiseDoneCallback, 0.0);
                        }
                    }

                    if (!elevatorLevelSafe)
                    {
                        if (robot.elevator.acquireExclusiveAccess(moduleName))
                        {
                            robot.elevator.setTarget(
                                moduleName, RobotParams.ELEVATOR_POS_FOR_TURRET_TURN, true, 1.0, null,
                                this::elevatorRaiseDoneCallback, 0.0);
                        }
                    }
                }
            }
        }
    }   //setPower

    /**
     * This method sets the turret in motion with the given power but it will first check if it's safe to turn the
     * turret. If not, it will instead raise the arm to above the safe level. Since setPower is generally called by
     * TeleOp code, it will not do the actual setPower after raising the arm because by the time the arm is raised
     * the gamepad control may have a different turret power value. Therefore, the TeleOp code will call again with
     * the new power value and this time it is safe to turn the turret.
     *
     * @param power specifies the power value to turn the turret.
     */
    public void setPower(double power)
    {
        setPower(power, true);
    }   //setPower

    /**
     * This method checks if the arm and elevator positions are safe to turn the turret to the given position without
     * hitting anything.
     *
     * @param target specifies the target position of the turret in degrees.
     * @param powerLimit specifies the maximum power the turret will turn.
     * @param event specifies the event to signal when the turret is on target, can be null if not provided.
     * @param callback specifies the notify callback to call when the turret is on target, can be null if not provided.
     * @param elevatorTarget specifies optionally the elevator target, can be null if no additional elevator movement.
     * @param armTarget specifies optionally the arm target, can be null if no additional arm movement.
     * @return true if it was safe and we successfully initiated the turn, false if we did not turn.
     */

     public void cancel()
    {
        pidTurret.cancel();
    }

}
